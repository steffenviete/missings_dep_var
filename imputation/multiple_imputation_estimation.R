##################################################################
#
#     multiple_imputation_estimation
#
##################################################################
# Content:
# - uses "imputed_sample.rda" generated by multiple_imputation_data.R to perform estimation on the imputed data



 library(splines)
 library(crs)
 library(sem)
 library(mi)
 library(Amelia)


#######################################################################
#
#         ESTIMATION
#
#######################################################################



#### load the imputed data frame
## Read the imputed data based on the SYNTHETIC DATA: This will not reproduce the original results of the paper
#load(paste(projectpath, "DATA/", "imputed_sample.rda", collapse="True", sep=""))


## Read the imputed data based on the ORIGINAL DATA: This is required to reproduce the original results of the paper
load(paste(projectpath, "DATA/", "imputations_16_08_17.rda", collapse="True", sep=""))



######use estimator on each of the imputed datasets
#create a list of dataframes out of the mi-object
impdata.frames <- complete(imputations, 5)
lapply(impdata.frames, summary)



coefs.impute.count <- NULL
ses.impute.count <- NULL

  
coefs.impute.tsls.count <- NULL
ses.impute.tsls.count <- NULL



#################################################
# LOOP: run the estimation on the 5 imputed datasets
##################################################
for (m  in  impdata.frames){
  

  W1 <- m$lnL 
  W1C <- m$lnC_raw_zero
  Y <- m$lnval 
  X <- as.numeric(as.character(m$v_out_b)) 
  W2 <- as.numeric(as.character(m$ber_y2k)) 
  br1 <- as.numeric(as.character(m$branche1)) 
  br2 <- as.numeric(as.character(m$branche2)) 
  br3 <- as.numeric(as.character(m$branche3)) 
  br4 <- as.numeric(as.character(m$branche4))
  br5 <- as.numeric(as.character(m$branche5))
  br6 <- as.numeric(as.character(m$branche6)) 
  br7 <- as.numeric(as.character(m$branche7))
  br8 <- as.numeric(as.character(m$branche8))
  br9 <- as.numeric(as.character(m$branche9)) 
  br10 <- as.numeric(as.character(m$branche10))
  br11 <- as.numeric(as.character(m$branche11)) 
  br12 <- as.numeric(as.character(m$branche12)) 
  br13 <- as.numeric(as.character(m$branche13))
  br14 <- as.numeric(as.character(m$branche14))
  ost <- as.numeric(as.character(m$ost))                                        
  pcwork <- m$pcwork
  
  BrDumDum <- cbind(br1, br2, br3, br4, br5, br6, br7, br8, br9, br10, br11, br13)
  BrDum <- cbind(ost, pcwork, BrDumDum)

  
  n = length(Y)
  
  
  ones<-rep(1,1,n)
  V<- cbind(Y,W1,W1C, W2)
  Z<- cbind(X,W1,W1C, W2)


  df1.c <- cv.g$K[1,2] +cv.g$K[1,1] #dimension = number of segements for W1 + order 2
  degree1.c <- cv.g$K[1,1] # is 2 since we use quadratic B-splines
  df2.c <- cv.g$K[2,2] +cv.g$K[2,1] #dimension = number of segements for W1 + order 2
  degree2.c <- cv.g$K[2,1] # is 2 since we use quadratic B-splines
  
  
  OtherControls <- BrDum[,]
  OC <- OtherControls
  
  

  # semiparametric estimation of structural parameter
  ####################################
  BasW1.mat = bs(W1, df=df1.c, degree=degree1.c)
  BasW1C.mat = bs(W1C, df=df2.c, degree=degree2.c)

  cond.mean.Y <- lm(Y~BasW1.mat+BasW1C.mat+OC[,1]+OC[,2]+OC[,3]+OC[,4]+OC[,5]
                    + OC[,6]+OC[,7]+OC[,8]+ OC[,9]+OC[,10]+OC[,11]
                    + OC[,12]+OC[,13]+OC[,14])$fitted.values

  
  cond.mean.X <- lm(X~BasW1.mat+BasW1C.mat
                    +OC[,1]+OC[,2]+OC[,3]+OC[,4]+OC[,5]+OC[,6]+OC[,7]+OC[,8]
                    + OC[,9]+OC[,10]+OC[,11]+OC[,12]+OC[,13]+OC[,14])$fitted.values
  
  coeff <- sum((Y-cond.mean.Y)*W2)/sum((X-cond.mean.X)*W2)
  coeff
  
  
  #store the coefficient of interest
  coefs.impute.count <- rbind(coefs.impute.count, coeff) # vector of coefficients obtained from individual imputaitons

  
  
  
  
  ###Linear Model
  ####################################

  XX <- cbind(X,W1, W1C, BrDum)
  ZZ <- cbind(W1,W1C, W2, BrDum) 
  tsls.est= tsls(Y~XX,~ZZ)
  tsls.est
  
  # store  vector with coefficients obtained from individual imputations
  coefs.impute.tsls.count <- rbind(coefs.impute.tsls.count, tsls.est$coeff[2]) 



  coefs.impute.count
  coefs.impute.tsls.count



  ######## bootstrap to get SE
  ####################################
  set.seed(12345)
  Conf.int1=matrix(nrow=2, ncol=1)
  impBootstrap.sample=vector()    
  impBootstrapTSLS.sample =vector()
  for (j in  1:reps){
    sample.index=vector()
    sample.index=sample(1:length(Y), replace=TRUE)
    Yb=vector() 
    Xb=vector() 
    W1b=vector()
    W1Cb=vector()
    W2b=vector()
    BrDumb = mat.or.vec(dim(BrDum)[1], dim(BrDum)[2])
  
    for (i in 1:length(Y)) Yb[i]=Y[sample.index[i]]
    for (i in 1:length(Y)) Xb[i]=X[sample.index[i]]
    for (i in 1:length(Y)) W2b[i]=W2[sample.index[i]]
    for (i in 1:length(Y)) W1b[i]=W1[sample.index[i]]
    for (i in 1:length(Y)) W1Cb[i]=W1C[sample.index[i]]
    for (i in 1:length(Y)) BrDumb[i,]=BrDum[sample.index[i],]

  
  
    n=length(Y)
  
  
    ones<- rep(1,n)

  

    OC = BrDumb[,]
    BasW1.mat = bs(W1b, df=df1.c, degree=degree1.c)
    BasW1C.mat = bs(W1Cb, df=df2.c, degree=degree2.c)

    
    cond.mean.Y <- lm((Yb)~BasW1.mat+BasW1C.mat+OC[,1]+OC[,2]+OC[,3]+OC[,4]+OC[,5]
                      + OC[,6]+OC[,7]+OC[,8]+ OC[,9]+OC[,10]+OC[,11]
                      + OC[,12]+OC[,13]+OC[,14])$fitted.values
    cond.mean.X <- lm(Xb~BasW1.mat+BasW1C.mat
                      +OC[,1]+OC[,2]+OC[,3]+OC[,4]+OC[,5]+OC[,6]+OC[,7]+OC[,8]
                      + OC[,9]+OC[,10]+OC[,11]+OC[,12]+OC[,13]+OC[,14])$fitted.values
    
    
    # Closed form Estimator BETA-Coefficient
    xx <- sum((Yb-cond.mean.Y)*W2b)/sum((Xb-cond.mean.X)*W2b)
    xx
  
    impBootstrap.sample[j] <- xx
    
    
    ######   Linear model 
    Y.barb <- Yb
    ### XX: exogenous variables
    XXb <- cbind(Xb,W1b, W1Cb, BrDumb) 
    ### ZZ: IT outsourcing and exogenous variables
    ZZb <- cbind(W1b,W1Cb, W2b, BrDumb) 
    
    # now use in 2sls
    tsls.est= tsls(Y.barb~XXb,~ZZb)
    tsls.est$coeff
    
    impBootstrapTSLS.sample[j] <- tsls.est$coeff[2]

    
  }

  
  #find SE
  ses.impute.count <- rbind(ses.impute.count, sd(impBootstrap.sample))

  
  #for linear model (Tsls) 
  ses.impute.tsls.count <- rbind(ses.impute.tsls.count,sd(impBootstrapTSLS.sample))
  
                                 
}
# END: loop over the 5 datasets ends
#####################################




#inspect vectors of individual estimates obtained form the imputed datasets
coefs.impute.count
ses.impute.count


coefs.impute.tsls.count
ses.impute.tsls.count


#past no Obs. to Results.N
Results.N[3] <- length(Y)
Results.N[4] <- length(Y)
Results.N[11] <- length(Y)
Results.N[12] <- length(Y)




###################################################################################
#Uses Rubin's rules for combining a set of results from multiply imputed datasets 
###################################################################################


#####Partially linear model
##Results of imputation 
mi.meld(coefs.impute.count, ses.impute.count)

res.impute.count <- t(do.call(rbind, mi.meld(coefs.impute.count, ses.impute.count)))
res.impute.count



#####linear model tsls
## Results of imputation 
res.impute.tsls.count <- t(do.call(rbind, mi.meld(coefs.impute.tsls.count, ses.impute.tsls.count)))
res.impute.tsls.count





